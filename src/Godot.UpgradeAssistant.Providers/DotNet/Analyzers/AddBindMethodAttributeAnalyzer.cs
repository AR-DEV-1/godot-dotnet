using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Godot.Common.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Godot.UpgradeAssistant.Providers;

[RequiresGodotDotNet]
[DiagnosticAnalyzer(LanguageNames.CSharp)]
internal sealed class AddBindMethodAttributeAnalyzer : DiagnosticAnalyzer
{
    private static DiagnosticDescriptor Rule =>
        Descriptors.GUA1008_AddBindMethodAttribute;

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics =>
        [Rule];

    public override void Initialize(DiagnosticAnalysisContext context)
    {
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();
        context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.Method);
    }

    private void AnalyzeSymbol(SymbolAnalysisContext context)
    {
        IMethodSymbol symbol = (IMethodSymbol)context.Symbol;

        if (!symbol.ContainingType.DerivesFromGodotSharpObject())
        {
            return;
        }

        if (symbol.OverridesFromGodotSharp())
        {
            // If the method is overriding a virtual method from the GodotSharp assembly,
            // those are already bound using the normal mechanism to bind virtual methods
            // so they don't need the attribute.
            return;
        }

        if (symbol.ContainingType.ContainingType is not null)
        {
            // If the method is contained in a nested type, it couldn't have been bound
            // because nested types can't be used as scripts with GodotSharp.
            return;
        }

        if (symbol.HasUnknownAttribute(KnownTypeNames.BindMethodAttribute))
        {
            // The method is already annotated with [BindMethod].
            return;
        }

        if (!IsMethodBound(symbol))
        {
            // The method is not bound, so we can ignore it.
            return;
        }

        if (!IsBoundMethodOverload(symbol))
        {
            // The method has overloads, and this overload was not bound.
            return;
        }

        var methodDeclarationSyntax = symbol.GetInSourceDeclarationSyntax<MethodDeclarationSyntax>();
        if (methodDeclarationSyntax is null)
        {
            // Could not find the method's declaration in source code, it must be a generated method.
            return;
        }

        context.ReportDiagnostic(Diagnostic.Create(
            descriptor: Rule,
            location: methodDeclarationSyntax.Identifier.GetLocation(),
            // Message Format parameters.
            symbol.ToDisplayString()));
    }

    private static bool IsMethodBound(IMethodSymbol symbol)
    {
        // In GodotSharp methods were bound implicitly as long as the parameter types were Variant-compatible,
        // but could be excluded using the [IgnoreMember] attribute.
        // For reference, see https://github.com/godotengine/godot/blob/a8a31456b549b99865168d880281ea0335a665d5/modules/mono/editor/Godot.NET.Sdk/Godot.SourceGenerators/ExtensionMethods.cs#L293-L326

        var attributes = symbol.GetAttributes();
        foreach (AttributeData attributeData in attributes)
        {
            var attributeSymbol = attributeData.AttributeClass;

            if (attributeSymbol.EqualsType("Godot.IgnoreMemberAttribute", "GodotSharp"))
            {
                // Method is explicitly excluded.
                return false;
            }
        }

        if (symbol.MethodKind != MethodKind.Ordinary)
        {
            // Only ordinary methods can be bound.
            return false;
        }

        if (symbol.IsImplicitlyDeclared)
        {
            // Methods generated by the compiler can't be bound.
            return false;
        }

        if (symbol.IsGenericMethod)
        {
            // Generic methods can't be bound.
            return false;
        }

        if (!symbol.ReturnsVoid)
        {
            if (!symbol.ReturnType.IsGodotSharpVariantCompatible())
            {
                return false;
            }
        }

        foreach (var parameterSymbol in symbol.Parameters)
        {
            if (parameterSymbol.RefKind != RefKind.None)
            {
                // Methods with ref-like parameters can't be bound.
                return false;
            }

            if (!parameterSymbol.Type.IsGodotSharpVariantCompatible())
            {
                return false;
            }
        }

        return true;
    }

    private static bool IsBoundMethodOverload(IMethodSymbol symbol)
    {
        // Adapted from https://github.com/godotengine/godot/blob/92e51fca7247c932f95a1662aefc28aca96e8de6/modules/mono/editor/Godot.NET.Sdk/Godot.SourceGenerators/ScriptMethodsGenerator.cs#L126-L135

        // While Godot technically doesn't support overloads, in GodotSharp we don't make a big effort to stop the user.
        // This results in complicated rules that are hard to reason about, and that may be surprising to the user.
        // However, the goal of the upgrade assistant is to try to maintain compatibility as much as possible, so we
        // need to preserve whatever behavior the user project had in GodotSharp even if it may not have been
        // intentional.
        //
        // To check if the current overload is the one that was bound in GodotSharp we follow these steps:
        //   1 - Get all the methods in the same way we did in GodotSharp.
        //   2 - Take the first method that matches the name and number of parameters.
        //   3 - That's the bound overload, compare it with the current method to see if it's the bound one.

        var boundOverload = symbol.ContainingType.GetMembers(symbol.Name)
            .Where(s => s.Kind == SymbolKind.Method && !s.IsImplicitlyDeclared)
            .Cast<IMethodSymbol>()
            .Where(m => m.MethodKind == MethodKind.Ordinary)
            .Where(IsMethodBound)
            .Distinct(new MethodOverloadEqualityComparer())
            .First(s => s.Name == symbol.Name && s.Parameters.Length == symbol.Parameters.Length);

        return SymbolEqualityComparer.Default.Equals(symbol, boundOverload);
    }

    private class MethodOverloadEqualityComparer : IEqualityComparer<IMethodSymbol>
    {
        // Adapted from https://github.com/godotengine/godot/blob/92e51fca7247c932f95a1662aefc28aca96e8de6/modules/mono/editor/Godot.NET.Sdk/Godot.SourceGenerators/ScriptMethodsGenerator.cs#L58-L70

        public bool Equals(IMethodSymbol? x, IMethodSymbol? y)
        {
            return x?.Parameters.Length == y?.Parameters.Length && x?.Name == y?.Name;
        }

        public int GetHashCode(IMethodSymbol obj)
        {
            unchecked
            {
                return (obj.Parameters.Length.GetHashCode() * 397) ^ obj.Name.GetHashCode();
            }
        }
    }
}
