using System.Collections.Immutable;
using Godot.Common.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Godot.UpgradeAssistant.Providers;

[RequiresGodotDotNet]
[DiagnosticAnalyzer(LanguageNames.CSharp)]
internal sealed class AddBindPropertyAttributeAnalyzer : DiagnosticAnalyzer
{
    private static DiagnosticDescriptor Rule =>
        Descriptors.GUA1007_AddBindPropertyAttribute;

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics =>
        [Rule];

    public override void Initialize(DiagnosticAnalysisContext context)
    {
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();
        context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.Property);
        context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.Field);
    }

    private void AnalyzeSymbol(SymbolAnalysisContext context)
    {
        ISymbol symbol = context.Symbol;

        if (!symbol.ContainingType.DerivesFromGodotSharpObject())
        {
            return;
        }

        if (symbol.HasUnknownAttribute(KnownTypeNames.BindPropertyAttribute))
        {
            // The member is already annotated with [BindProperty].
            return;
        }

        if (!IsMemberBound(symbol))
        {
            // The member is not bound, so we can ignore it.
            return;
        }

        var memberDeclarationSyntax = symbol.GetInSourceDeclarationSyntax<MemberDeclarationSyntax>();
        if (memberDeclarationSyntax is null)
        {
            // Could not find the member's declaration in source code, it must be a generated member.
            return;
        }

        var location = memberDeclarationSyntax switch
        {
            FieldDeclarationSyntax fieldDeclarationSyntax =>
                fieldDeclarationSyntax.Declaration.Variables.First().Identifier.GetLocation(),

            PropertyDeclarationSyntax propertyDeclarationSyntax =>
                propertyDeclarationSyntax.Identifier.GetLocation(),

            _ =>
                null,
        };
        if (location is null)
        {
            // Could not find a suitable location to report the diagnostic.
            return;
        }

        context.ReportDiagnostic(Diagnostic.Create(
            descriptor: Rule,
            location: location,
            // Message Format parameters.
            symbol.ToDisplayString()));
    }

    private static bool IsMemberBound(ISymbol symbol)
    {
        // In GodotSharp members were bound implicitly as long as the type was Variant-compatible,
        // but could be excluded using the [IgnoreMember] attribute.
        // Members could also be bound explicitly with the [Export] attribute.
        // For reference, see https://github.com/godotengine/godot/blob/a8a31456b549b99865168d880281ea0335a665d5/modules/mono/editor/Godot.NET.Sdk/Godot.SourceGenerators/ExtensionMethods.cs#L342-L373

        var attributes = symbol.GetAttributes();
        foreach (AttributeData attributeData in attributes)
        {
            var attributeSymbol = attributeData.AttributeClass;

            if (attributeSymbol.EqualsType("Godot.IgnoreMemberAttribute", "GodotSharp"))
            {
                // Member is explicitly excluded.
                return false;
            }

            if (attributeSymbol.EqualsType("Godot.ExportAttribute", "GodotSharp"))
            {
                // Member is explicitly included, we'll assume it's Variant-compatible.
                return true;
            }
        }

        if (symbol.IsStatic)
        {
            // Static members can't be bound.
            return false;
        }

        ITypeSymbol memberTypeSymbol;
        switch (symbol)
        {
            case IFieldSymbol fieldSymbol:
            {
                if (fieldSymbol.IsImplicitlyDeclared)
                {
                    // Fields generated by the compiler can't be bound.
                    return false;
                }

                if (fieldSymbol.IsReadOnly)
                {
                    // Read-only fields can't be bound.
                    return false;
                }

                memberTypeSymbol = fieldSymbol.Type;
                break;
            }

            case IPropertySymbol propertySymbol:
            {
                if (propertySymbol.IsIndexer)
                {
                    // Indexer properties can't be bound.
                    return false;
                }

                if (propertySymbol.ExplicitInterfaceImplementations.Length != 0)
                {
                    // Explicit interface implementations can't be bound.
                    return false;
                }

                if (propertySymbol.IsReadOnly || propertySymbol.IsWriteOnly)
                {
                    // Properties that are read-only or write-only can't be bound.
                    return false;
                }

                if (propertySymbol.SetMethod is null || propertySymbol.SetMethod.IsInitOnly)
                {
                    // Properties without a setter or with an init-only setter can't be bound.
                    return false;
                }

                memberTypeSymbol = propertySymbol.Type;
                break;
            }

            default:
            {
                // Only fields and properties can be bound.
                return false;
            }
        }

        if (!memberTypeSymbol.IsGodotSharpVariantCompatible())
        {
            // Member type must be Variant-compatible.
            return false;
        }

        if (!symbol.ContainingType.DerivesFrom("Godot.Node", "GodotSharp"))
        {
            if (memberTypeSymbol.DerivesFrom("Godot.Node", "GodotSharp"))
            {
                // If the containing type is not Node or derives from Node,
                // then the member type can't be Node or derived from Node either.
                return false;
            }
        }

        return true;
    }
}
